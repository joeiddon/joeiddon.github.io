---
layout: default
---

<h1>Creating Perlin Noise in JS</h1>
<script src='https://joeiddon.github.io/perlin/perlin.js'></script>

<p>
Perlin noise is a type of random, yet smooth, noise that can be
easily generated using a particular algorithm.
</p>

<!--
<p>
The output is particularly useful in computer graphics where it can be used for
things such as textures, flames, smoke, and terrain - what I will be using it for. The most
well known place Perlin noise is implemented is Minecraft where it is used
generate the landscape so the hills, caves and so on.
</p>

<p>
Following <a href='https://en.wikipedia.org/wiki/Perlin_noise'>the
Wikipedia article on this topic</a>, I managed to successfully write code to
generate it. These are the steps:
</p>

<ol>
<li>Define an n-dimensional grid.
<li>For each node of the grid assign a random gradient vector of unit length in n dimensions.
<li>Given an n-dimensional argument for the noise function.
<li>Determine its cell in the grid.
<li>For each corner node of that cell, calculate the distance vector between
the point and the node.
<li>Compute the dot product between the gradient vector and the distance
vector.
<li>Interpolate the 2^n dot products to get the value.
</ol>

<p>
Of course we will be generating two-dimensional (n = 2) noise. <em>(Aside:
Here is <a href='https://youtu.be/obCjODeoLVw?t=148'>a clip of Professor
Feynman</a> making a joke about mathematicians generalising for
n-dimensions.)</em>
</p>
-->

<!--The physicist, interested only in our
three-dimensional world, complains. "Substitute n equals three!" the
mathematicians say.]</em>
</p>-->

<p>
Before delving into the steps to generate Perlin noise, let's inspect the
output.
</p>

<style>
input {
    padding: 0.3em;
    margin: 0.4em;
}
canvas {
    width: 350px;
    height: 350px;
}
</style>
<div style='display: flex; justify-content: space-around'>
<div><canvas id='cnvsa'></canvas><p style='text-align: center'>Static Noise</p></div>
<div><canvas id='cnvsb'></canvas><p style='text-align: center'>Perlin Noise</p></div>
</div>
<div style='text-align: center'>
<input type='button' value='Regenerate' onclick='render();'></input>
<input type='button' value='Increase Resolution' onclick='resolution *=
2;render();if (resolution == 128) this.disabled = true;
this.nextElementSibling.disabled=false;'></input>
<input type='button' value='Decrease Resolution' onclick='resolution /=
2;render();if (resolution == 8) this.disabled = true;
this.previousElementSibling.disabled=false;'></input>
<input type='button' value='Increase Nodes' onclick='gridSize *=
2;render();if (gridSize > 8)this.disabled=true;this.nextElementSibling.disabled=false;'></input>
<input type='button' value='Decrease Nodes' onclick='gridSize /=
2;render();if (gridSize ==
1)this.disabled=true;this.previousElementSibling.disabled=false;'></input>
<input type='button' value='Reset' onclick='reset();render();'></input>
</div>
<script>
var cnvsa = document.getElementById('cnvsa')
var cnvsb = document.getElementById('cnvsb')
var ctxa = cnvsa.getContext('2d')
var ctxb = cnvsb.getContext('2d')

var w = 256;
cnvsa.width = cnvsa.height = cnvsb.width = cnvsb.height = w;

var gridSize, resolution;
function reset() {
    gridSize = 4;
    resolution = 64;
    let inpts = document.getElementsByTagName('input');
    for (let i = 0; i < inpts.length; i++){
        inpts[i].disabled = false;
    }
}

reset();

function render() {
    let  pixSize = w / resolution;

    ctxa.clearRect(0, 0, cnvsa.width, cnvsa.width);
    ctxb.clearRect(0, 0, cnvsb.width, cnvsb.width);
    perlin.seed();
    for (var y = 0; y < gridSize; y += gridSize / resolution){
        for (var x = 0; x < gridSize; x += gridSize / resolution){
            var v = parseInt(Math.random() * 255)
            ctxa.fillStyle = 'rgb(' + v + ',' + v + ',' + v + ')'
            ctxa.fillRect(x * (w / gridSize), y * (w / gridSize), pixSize, pixSize)
        }
    }

    for (var y = 0; y < gridSize; y += gridSize / resolution){
        for (var x = 0; x < gridSize; x += gridSize / resolution){
            var v = parseInt((perlin.get(x, y)/2+0.5) * 255)
            ctxb.fillStyle = 'rgb(' + v + ',' + v + ',' + v + ')'
            ctxb.fillRect(x * (w / gridSize), y * (w / gridSize), pixSize, pixSize)
        }
    }
}
render();
//setInterval(render, 4000);
</script>


<p>Okay so how do we write this in JavaScript? First we will write it the
straightforward way, then we will optimise it for efficiency and
simplicity.</p>

<hr>

<p><strong>Step 1:</strong> We need a two-dimensional grid of "nodes". The size of this
grid determines roughly how zoomed in our noise is going to be.</p>

<p>In JavaScript we can use a nested array to describe this grid. This means it
is initialised as empty then rows are appended, but this will come later.</p>

<p>The variable <code>nodes</code> defines the number of nodes we have in
each dimension.</p>

<pre>
let grid = [];
const nodes = 4;
</pre>

<p>At this point you may be wondering: what is a node? It is simply a unit
vector describing the slope of the noise at fixed intervals in the image.</p>

<!--<p>This is <strong>the key to Perlin noise</strong>:</p> To determine the
intensity of a pixel at some position in the image, we calculate the dot
product of the displacement vector from its position to each of the four
closest nodes in the nodes grid, with that node's unit vector.
We then interpolate dot products of each displacement vector and unit vector.
This value i-->

<hr>

<p><strong>Step 2:</strong> Assign a random gradient vector of unit length to
each node of the grid.</p>

<p>A unit vector is simply a pair of numbers, (x, y), that has a length of one. (I.e. x<sup>2</sup> +
y<sup>2</sup> = 1.)</p>

<p>There are a couple of diferent ways to randomly generate these, but possibly
the simplest is to generate a random angle and then use the sine and cosine
<a href='https://joeiddon.github.io/projects/javascript/trigonometry'>trigonometric functions</a> built in to JavaScript.</p>


<p><em><strong>Additional:</strong> We refer to these as "gradient" vectors because they
are going to determine the slope of the terrain/noise at each point in the
grid. A continuous function is then created through interpolation between these
gradients.</em></p>

<!--
<div style='border: 1px solid black;position: absolute;right:
0;background:white;'>
<canvas id='cnvs1'></canvas>
<div style='text-align:center;'>Random unit vectors.</div>
</div>
<div><pre>
function random_unit_vector(){
    let theta = Math.random() * 2 * Math.PI;
    return {
        x: Math.cos(theta),
        y: Math.sin(theta)
    };
}
</pre></div>
<script>
function line(cx, x1, y1, x2, y2) {
    cx.beginPath();
    cx.moveTo(x1, y1);
    cx.lineTo(x2, y2);
    cx.closePath();
    cx.stroke();
}

function draw_arrow(cx, x1, y1, x2, y2, l) {
    let r = ((x1-x2)**2 + (y1-y2)**2)**0.5;
    let rx = x2 - x1;
    let ry = y1 - y2;
    line(cx, x1, y1, x2, y2);
    let m = [
        [rx/r, -ry/r],
        [ry/r, rx/r]
    ];
    let rot = (x,y) => [m[0][0]*x + m[0][1]*y, m[1][0]*x + m[1][1]*y];
    let head1 = rot(-l/2**0.5,l/2**0.5);
    let head2 = rot(-l/2**0.5,-l/2**0.5);
    line(cx, x2, y2, x2 + head1[0], y2 - head1[1]);
    line(cx, x2, y2, x2 + head2[0], y2 - head2[1]);
}

var cnvs1 = document.getElementById('cnvs1');
cnvs1.width = 300;
cnvs1.height = 250;
var ctx1  = cnvs1.getContext('2d');
let vectors = [];
const NUM = 5;
const INTERVAL = 1000;
let last_update_ms = 0;
function update(time_ms){
if (time_ms - last_update_ms > INTERVAL) {
    last_update_ms = time_ms;
    vectors.unshift([time_ms, perlin.rand_vect()]);
    if (vectors.length > NUM) vectors.pop();
}
ctx1.clearRect(0, 0, cnvs1.width, cnvs1.height);
ctx1.textBaseline = 'middle';
ctx1.textAlign = 'center';
ctx1.font = '12px monospace';
for (let i = 0; i < vectors.length; i++){
let [created, vector] = vectors[i];
let head = [cnvs1.width/2 + vector.x * 100, cnvs1.height/2 - vector.y * 100];
//let v = (1 - i / NUM)*(1 - (time_ms - last_update_ms)/NUM/INTERVAL);
//let v = (1 - i / NUM)*(1 - (time_ms - (last_update_ms))/NUM/INTERVAL);
let v = 1-(time_ms - created)/(INTERVAL*NUM);
ctx1.strokeStyle = ctx1.fillStyle = 'hsl(0,0%,' + 100 * (1-v) +'%)';
ctx1.lineWidth = 2;
draw_arrow(ctx1, cnvs1.width/2, cnvs1.height/2, ...head, 15);
ctx1.fillText(`(${vector.x.toFixed(2)}, ${vector.y.toFixed(2)})`, head[0],
    head[1] + (vector.y < 0 ? 15 : -15));
}
requestAnimationFrame(update);
}

requestAnimationFrame(update);
</script>
-->

<p>Let's make a function to do this random vector generation. It will return
the coordinate as an object with <code>x</code> and <code>y</code>
attributes.</p>

<pre>
function random_unit_vector(){
    let theta = Math.random() * 2 * Math.PI;
    return {x: Math.cos(theta), y: Math.sin(theta)};
}
</pre>

<p>Now we need to populate the grid with these random vectors. A nested
for-loop can be used.</p>

<pre>
for (let i = 0; i < nodes; i++) {
    let row = [];
    for (let j = 0; j < nodes; j++) {
        row.push(random_unit_vector());
    }
    grid.push(row);
}
</pre>

<hr>

<p><strong>Step 3:</strong> We need to accept the input to the noise function
as an (x,y) coordinate.</p>

<p>Taking a step back - what functionality are we trying to provide here? The
Perlin noise algorithm describes a function. This takes an input of a
2D coordinate, and returns a number. The number
determines the intensity/"height" of the noise at that coordinate.</p>

<p>But how can a function that returns an intensity be used to create the
smooth image shown at the start of this article? The answer - the image is not
continuous, but discrete or "pixelated". So the image is created by iterating
over each pixel coordinate, running the Perlin function for that coordinate,
and assigning the intensity to that pixel.</p>

<p>Alternatively, if we wanted to generate a 3D landscape using the noise
function, we would have to make it discrete by sampling heights only at fixed
positions (nodes in a pixelated grid) and <a
href='https://joeiddon.github.io/zengine/demos/terrain.html'>piece together
triangular pieces to give a 3D landscape.</a></p>

<p>Therefore we need a function. Lets call it <code>perlin_get</code>, and it
will take a two-dimensional input (x and y), and return an
<em>intensity</em>.</p>

<pre>
function perlin_get(x, y) {
    ...
    return intensity;
}
</pre>

<hr>

<p>
<strong>Step 4:</strong> Determine its cell in the grid, where the "cell" is
the square of integer coordinates around our x and y. For example, if x = 1.4
and y = 3.6, then the cell is from x = 1 to 2 and y = 3 to 4.
</p>

<p>
How do we do this in JavaScript? Well we can use the
<a
href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor'><code>Math.floor(...)</code></a>
function.
</p>

<pre>
let x0 = Math.floor(x);
let x1 = x0 + 1;
let y0 = Math.floor(y);
let y1 = y0 + 1;
</pre>

<p>
Having found the cell nodes, we can calculate the dot product between the distance vector between the point and the node and the random gradient vector from our array. Calculating the distance vector and the dot product can be condensed together into one function:
</p>

<pre>
function dot_prod_grid(x, y, vert_x, vert_y){
    var g_vect = gradients[vert_y][vert_x];
    var d_vect = {x: x - vert_x, y: y - vert_y};
    return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
}
</pre>

<p>
Finally, we need to <a href='https://en.wikipedia.org/wiki/Interpolation'>interpolate</a> between the four cell node dot-products (scalars). Interpolation is a way of constructing new data points within a range of others. To do this, a function is used, the simplest being linear:
</p>

<pre>
function lin_interp(x, a, b){
    return a + x * (b-a);
}
</pre>

<p>
So if we run linTerp(0, 56, 98) we will get 56 and if we run with x = 1 we get b so 98 in this case. The point of the interpolation is that now, any value of x will map between the two outer values. So running linTerp(0.5, 24, 64) will give us the value exactly in the middle so 44. However, linear interpolation produces slight 'ridges' inbetween each cell as their is no curves, just straight lines. To add a very rounded and smooth looking curve/ fade inbetween the cells, we can use Perlin's smootherstep function (a quintic polynomial):
</p>

<pre>
smootherstep: function(x){
    return 6*x**5 - 15*x**4 + 10*x**3;
},
interp: function(x, a, b){
    return a + smootherstep(x) * (b-a);
},
</pre>

<p>
To interpolate between the four cell nodes with this function, we must do so in three steps (bilenear interpolation). First by interpolating how far the x distance of the input is into the cell (between 0 and 1) between the top two dot-products and then interpolating the inputs x value into the cell again between the bottom two dot-products of the cell. Finally, interpolate between the two previous values to get the final value for that noise which will be returned from the library. Note that as the function returns a value between -1 and 1, and I would like it to return a value between 0 and 1, the final value is mapped to my range by incrementing and dividing by 2.
</p>

<p>And that's it for the explanation. Head over to GitHub where you can view my
finished <a href='https://github.com/joeiddon/perlin'>Perlin Noise
library</a>.</p>

<p>
Update 06/01/2021: Shoutout to Julian Fietkau for <a
href='https://fietkau.plus/#perlin_terrain'>his use of my library.</a></p>

To see how this
result can be used for something more interesting than these blurry gradients,
checkout <a href='https://joeiddon.github.io/projects/javascript/terrain'>my 3D
terrain generator</a>.

<!--<p>See a <a href='https://joeiddon.github.io/perlin/demo'>color demonstration
here</a>.</p>-->
